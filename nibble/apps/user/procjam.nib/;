require('GrammarLang')

local TilemapBuilder = require('TilemapBuilder')
local Tile = require('Tile')

-- All functions here operate on an instance
-- of TilemapBuilder

local T_SHADOW = 6
local N_FLOOR = 7

-- Non-Terminals
local N_NONE = 2000
local N_WALL = 1000
local N_FLOOR = 1001

-- Door size
local DOOR_SIZE = 2

function g_hsplit(builder, p, fn)
    builder:use(0, 0, p, 1)
    fn(builder)
    builder:restore()

    builder:use(p, 0, 1-p, 1)
    fn(builder)
    builder:restore()
end

function g_vsplit(builder, p, fn)
    builder:use(0, 0, 1, p)
    fn(builder)
    builder:restore()

    builder:use(0, p, 1, 1-p)
    fn(builder)
    builder:restore()
end

function g_room(builder, top_door, bottom_door, left_door, right_door)
    builder:use(0, 0, 1, 1)

    local bounds = builder:bounds()

    if bounds.w >= 12 and bounds.h >= 12 then
        local split_position = math.floor(math.random()*3)/4+1/4;

        if math.random() > 0.5 then
            g_hsplit(builder, split_position, g_room)
        else
            g_vsplit(builder, split_position, g_room)
        end
    else
        builder:topleft_half_borders(N_WALL)

        if bounds.y > 0 then
            local top_door = math.random(bounds.x+1, bounds.x+bounds.w-2)

            for i=0,DOOR_SIZE-1 do
                builder:set(top_door+i, bounds.y, N_FLOOR)
            end
        end

        if bounds.x > 0 then
            local left_door = math.random(bounds.y+1, bounds.y+bounds.h-2)

            for i=0,DOOR_SIZE-1 do
                builder:set(bounds.x, left_door+i, N_FLOOR)
            end
        end
    end

    if bounds.w == 20 and bounds.h == 15 then
        builder:bottomright_half_borders(N_WALL)

        g_external_doors(builder, top_door, bottom_door, left_door, right_door)

        g_apply_grammar(builder)
    end

    builder:restore()

    return builder
end

function g_external_doors(builder, top_door, bottom_door, left_door, right_door)
    local bounds = builder:bounds()

    if top_door then
        local top_door = math.random(bounds.x+1, bounds.x+bounds.w-DOOR_SIZE-1)

        for i=0,DOOR_SIZE-1 do
            builder:set(top_door+i, bounds.y, N_FLOOR)
        end
    end

    if bottom_door then
        local bottom_door = math.random(bounds.x+1, bounds.x+bounds.w-DOOR_SIZE-1)

        for i=0,DOOR_SIZE-1 do
            builder:set(bottom_door+i, bounds.y+bounds.h-1, N_FLOOR)
        end
    end

    if left_door then
        local left_door = math.random(bounds.y+1, bounds.y+bounds.h-DOOR_SIZE-1)

        for i=0,DOOR_SIZE-1 do
            builder:set(bounds.x, left_door+i, N_FLOOR)
        end
    end

    if right_door then
        local right_door = math.random(bounds.y+1, bounds.y+bounds.h-DOOR_SIZE-1)

        for i=0,DOOR_SIZE-1 do
            builder:set(bounds.x+bounds.w-1, right_door+i, N_FLOOR)
        end
    end
end

function g_apply_grammar(builder)
    local max_iterations = 1

    while not builder:all_terminals() and max_iterations > 0 do
        -- Operate in the entire builder that was passed to us
        builder:use(0, 0, 1, 1)

        local bounds = builder:bounds()


        for y=bounds.y-1,bounds.y+bounds.h-h+1 do
            for x=bounds.x-1,bounds.x+bounds.w-w+1 do
                local copy = self:copy()
                copy:use_exact(x, y, w, h)

                fn(copy)

                table.insert(self.results, copy)
            end
        end

        builder:each(1, 1, function (block)
            if block:is({N_FLOOR}) then
                block:into({7})
            end
        end)

        builder:apply()
        -- Operate in the previous context
        builder:restore()

        max_iterations -= 1
    end
end
